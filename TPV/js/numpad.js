var Calc = (function() {	var DIVIDE = 247;	var MULTIPLY = 215;	var SUBTRACT = 45;	var ADD = 43;	var MIN_RESULT_FONT_SIZE = 16;	var MAX_CHARS_SHOWABLE_IN_RESULT_INPUT = 1000;	var resultInput = null;	var basicTable = null;	var credits = null;	var container = null;	var viewportWidth = null;	var viewportHeight = null;	var calcStr = "";	return new function() {		var _self = this;		this.insert_at_cursor = function(_inputField, _str) {			// TODO: this doesn't yet work correctly in all browsers.			_inputField.focus();			// IE support			if (document.selection) {				sel = document.selection.createRange();				sel.text = _str;			}			// MOZILLA/NETSCAPE support			else if (_inputField.selectionStart || _inputField.selectionStart == '0') {				var startPos = _inputField.selectionStart;				var endPos = _inputField.selectionEnd;				_inputField.value = _inputField.value.substring(0, startPos) + _str + _inputField.value.substring(endPos, _inputField.value.length);			} else {				_inputField.value += _str;			}		}		this.input_keypress_handler = function(e) {			var buttons = document.getElementsByTagName("button");			for (var i=0; i<buttons.length; ++i) {				if (buttons[i].hasAttribute("data-keypress") && e.charCode == parseInt(buttons[i].getAttribute("data-keypress"))) {					_self.insert_at_cursor(resultInput, buttons[i].getAttribute("data-char"));					break;				}			}                        			// only allow backspace (8) and del (46) from this point onwards			if (8 != e.keyCode && 46 != e.keyCode) {				e.preventDefault();				e.stopPropagation();			}			calcStr = resultInput.value; 		}		this.begin_direct_edit = function() {			resultInput.value = calcStr;			return false;		}		this.end_direct_edit = function() {			_self.update_result_display();			return false;		}		this.init = function() {			resultInput = document.getElementById("resultInput");			resultInput.onfocus = _self.begin_direct_edit;			resultInput.onblur = _self.end_direct_edit;			resultInput.onkeypress = _self.input_keypress_handler;			basicTable = document.getElementById("basic");			credits = document.getElementById("credits");			container = document.getElementById("container");			_self.redraw();		}		this.redraw = function() {                    			// viewport: http://javascript.about.com/od/browserobjectmodel/a/bom10.htm, http://www.quirksmode.org/dom/w3c_cssom.html#windowview			viewportWidth = parseInt(window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth);			viewportHeight = parseInt((window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight) * 0.98);			container.style.width = viewportWidth + "px";			container.style.height = viewportHeight + "px";			// font size			var fontSize = parseInt(resultInput.offsetHeight * 0.9);			if (MIN_RESULT_FONT_SIZE > fontSize) fontSize = MIN_RESULT_FONT_SIZE;			document.body.style.fontSize = fontSize + "px";			MAX_CHARS_SHOWABLE_IN_RESULT_INPUT = parseInt(1.7 * resultInput.offsetWidth / fontSize) - 1;			// table width 			basicTable.style.width = (viewportWidth < basicTable.offsetHeight ? parseInt(viewportWidth * 0.99): basicTable.offsetHeight) + "px";			// credits			credits.style.fontSize = (credits.offsetHeight - 2) + "px";		}		this.update_result_display = function() {			if (calcStr.length >= MAX_CHARS_SHOWABLE_IN_RESULT_INPUT)				resultInput.value = calcStr.substr(calcStr.length-MAX_CHARS_SHOWABLE_IN_RESULT_INPUT);			else				resultInput.value = calcStr;		}		this.append = function(_buttonElem) {                        if (document.getElementById("first") && document.getElementById("first").value==""){                            calcStr = "";                        }			calcStr += _buttonElem.getAttribute("data-char");			_self.update_result_display();                        if (document.getElementById("first")){                            document.getElementById("first").value = calcStr;                        }		}                		this.clear = function() {			calcStr = "";			_self.update_result_display();                        if (document.getElementById("first")){                            document.getElementById("first").value = calcStr;                        }		}		this.backspace = function() {			if (1 <= calcStr.length)				calcStr = calcStr.substr(0, calcStr.length-1);			_self.update_result_display();                        if (document.getElementById("first")){                            document.getElementById("first").value = calcStr;                        }		}		this.precedes = function(beforeOp, afterOp) { // BODMAS			if (DIVIDE == afterOp && DIVIDE != beforeOp)				return false;			else if (MULTIPLY == afterOp && DIVIDE != beforeOp && MULTIPLY != beforeOp)				return false;			else				return true;		}		this.equals = function() {			_self.end_direct_edit(); // just in case			// convert infix to postfix			var opStack = new Array();			var postfix = new Array();			var infix = calcStr;			// if starts with a minus then assume it's a negative number (probably result of a previous calculation)			if (SUBTRACT == infix.charCodeAt(0))				infix = "0" + infix;			var currentNum = "";			for (var i=0; i<infix.length; ++i) {				var c = infix.charCodeAt(i);				if (DIVIDE == c || MULTIPLY == c || SUBTRACT == c || ADD == c) {					// add current number to output					if (0 < currentNum.length) {						postfix.push(currentNum);						currentNum = "";					}					// pop off any operators with higher precedence than this one					while (0 < opStack.length) {						var top = opStack[opStack.length-1];						if (!this.precedes(top, c))							break;						postfix.push(String.fromCharCode(opStack.pop()));					}					opStack.push(c);				// check that it's a number or a decimal point				} else if ( (48 <= c && 57 >= c) || 46 == c ) {					var cStr = String.fromCharCode(c);					// if it's a decimal point check that we haven't already encountered a decimal point					if (46 == c && -1 != currentNum.indexOf(cStr)) {						alert("Extra decimal point detected after '" + currentNum + "'");						return;					}					currentNum += cStr;				} else {					alert("Invalid character: " + String.fromCharCode(c));					return;				}			}			// add remaining number to output			if (0 < currentNum.length) {				postfix.push(currentNum);				currentNum = "";			}			// add remaining operators (LIFO)			while (0 < opStack.length) {				postfix.push(String.fromCharCode(opStack.pop()));			}			// start evaluating			var evalStack = new Array();			for (var i = 0; postfix.length > i; ++i) {				var nextToken = postfix[i];				var c = nextToken.charCodeAt(0);				// if it's an op				if (DIVIDE == c || MULTIPLY == c || SUBTRACT == c || ADD == c) {					// need atleast two values on stack					if (2 > evalStack.length) {						alert("Not enough numbers entered for all operations!");						return;					} else {						var arg2 = parseFloat(evalStack.pop());						var arg1 = parseFloat(evalStack.pop());						var ret = _self.eval2(c, arg1, arg2);						if ('&infin;' == ret) {							alert("Result is infinity!");							return;						}						evalStack.push(ret);					}				// if it's a number				} else {					// push it up					evalStack.push(nextToken);				}			}			// if more than one value left on stack then too many operands given			if (1 < evalStack.length) {				alert("You supplied more numbers than needed. Did you miss something?");				return;			} else {				// write to output, as integer if possible				var finalResult = parseFloat(evalStack.pop());				calcStr = "" + ((parseInt(finalResult) * 1.0) == finalResult ? parseInt(finalResult) : finalResult);				resultInput.value = calcStr;				resultInput.blur();			}		}		this.eval2 = function(op, arg1, arg2) {			var ret = 0;			switch (op) {				case DIVIDE:					ret = 0 == arg2 ? '&infin;' : arg1 / arg2;					break;				case MULTIPLY:					ret = arg1 * arg2;					break;				case SUBTRACT:					ret = arg1 - arg2;					break;				case ADD:					ret = arg1 + arg2;					break;			}			return ret;		}	}})();